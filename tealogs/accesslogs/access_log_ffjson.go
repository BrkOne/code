// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: access_log.go

package accesslogs

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
)

// MarshalJSON marshal bytes to json - template
func (j *AccessLog) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLog) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.Id.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"serverId":`)
	fflib.WriteJsonString(buf, string(j.ServerId))
	buf.WriteString(`,"backendId":`)
	fflib.WriteJsonString(buf, string(j.BackendId))
	buf.WriteString(`,"locationId":`)
	fflib.WriteJsonString(buf, string(j.LocationId))
	buf.WriteString(`,"fastcgiId":`)
	fflib.WriteJsonString(buf, string(j.FastcgiId))
	buf.WriteString(`,"rewriteId":`)
	fflib.WriteJsonString(buf, string(j.RewriteId))
	buf.WriteString(`,"teaVersion":`)
	fflib.WriteJsonString(buf, string(j.TeaVersion))
	buf.WriteString(`,"remoteAddr":`)
	fflib.WriteJsonString(buf, string(j.RemoteAddr))
	buf.WriteString(`,"remotePort":`)
	fflib.FormatBits2(buf, uint64(j.RemotePort), 10, j.RemotePort < 0)
	buf.WriteString(`,"remoteUser":`)
	fflib.WriteJsonString(buf, string(j.RemoteUser))
	buf.WriteString(`,"requestURI":`)
	fflib.WriteJsonString(buf, string(j.RequestURI))
	buf.WriteString(`,"requestPath":`)
	fflib.WriteJsonString(buf, string(j.RequestPath))
	buf.WriteString(`,"apiPath":`)
	fflib.WriteJsonString(buf, string(j.APIPath))
	buf.WriteString(`,"apiStatus":`)
	fflib.WriteJsonString(buf, string(j.APIStatus))
	buf.WriteString(`,"requestLength":`)
	fflib.FormatBits2(buf, uint64(j.RequestLength), 10, j.RequestLength < 0)
	buf.WriteString(`,"requestTime":`)
	fflib.AppendFloat(buf, float64(j.RequestTime), 'g', -1, 64)
	buf.WriteString(`,"requestMethod":`)
	fflib.WriteJsonString(buf, string(j.RequestMethod))
	buf.WriteString(`,"requestFilename":`)
	fflib.WriteJsonString(buf, string(j.RequestFilename))
	buf.WriteString(`,"scheme":`)
	fflib.WriteJsonString(buf, string(j.Scheme))
	buf.WriteString(`,"proto":`)
	fflib.WriteJsonString(buf, string(j.Proto))
	buf.WriteString(`,"bytesSent":`)
	fflib.FormatBits2(buf, uint64(j.BytesSent), 10, j.BytesSent < 0)
	buf.WriteString(`,"bodyBytesSent":`)
	fflib.FormatBits2(buf, uint64(j.BodyBytesSent), 10, j.BodyBytesSent < 0)
	buf.WriteString(`,"status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteString(`,"statusMessage":`)
	fflib.WriteJsonString(buf, string(j.StatusMessage))
	buf.WriteString(`,"sentHeader":`)
	/* Falling back. type=map[string][]string kind=map */
	err = buf.Encode(j.SentHeader)
	if err != nil {
		return err
	}
	buf.WriteString(`,"timeISO8601":`)
	fflib.WriteJsonString(buf, string(j.TimeISO8601))
	buf.WriteString(`,"timeLocal":`)
	fflib.WriteJsonString(buf, string(j.TimeLocal))
	buf.WriteString(`,"msec":`)
	fflib.AppendFloat(buf, float64(j.Msec), 'g', -1, 64)
	buf.WriteString(`,"timestamp":`)
	fflib.FormatBits2(buf, uint64(j.Timestamp), 10, j.Timestamp < 0)
	buf.WriteString(`,"host":`)
	fflib.WriteJsonString(buf, string(j.Host))
	buf.WriteString(`,"referer":`)
	fflib.WriteJsonString(buf, string(j.Referer))
	buf.WriteString(`,"userAgent":`)
	fflib.WriteJsonString(buf, string(j.UserAgent))
	buf.WriteString(`,"request":`)
	fflib.WriteJsonString(buf, string(j.Request))
	buf.WriteString(`,"contentType":`)
	fflib.WriteJsonString(buf, string(j.ContentType))
	if j.Cookie == nil {
		buf.WriteString(`,"cookie":null`)
	} else {
		buf.WriteString(`,"cookie":{ `)
		for key, value := range j.Cookie {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.WriteJsonString(buf, string(value))
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteString(`,"arg":`)
	/* Falling back. type=map[string][]string kind=map */
	err = buf.Encode(j.Arg)
	if err != nil {
		return err
	}
	buf.WriteString(`,"args":`)
	fflib.WriteJsonString(buf, string(j.Args))
	buf.WriteString(`,"queryString":`)
	fflib.WriteJsonString(buf, string(j.QueryString))
	buf.WriteString(`,"header":`)
	/* Falling back. type=map[string][]string kind=map */
	err = buf.Encode(j.Header)
	if err != nil {
		return err
	}
	buf.WriteString(`,"serverName":`)
	fflib.WriteJsonString(buf, string(j.ServerName))
	buf.WriteString(`,"serverPort":`)
	fflib.FormatBits2(buf, uint64(j.ServerPort), 10, j.ServerPort < 0)
	buf.WriteString(`,"serverProtocol":`)
	fflib.WriteJsonString(buf, string(j.ServerProtocol))
	buf.WriteString(`,"backendAddress":`)
	fflib.WriteJsonString(buf, string(j.BackendAddress))
	buf.WriteString(`,"fastcgiAddress":`)
	fflib.WriteJsonString(buf, string(j.FastcgiAddress))
	buf.WriteString(`,"requestData":`)
	if j.RequestData != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(j.RequestData)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"responseHeaderData":`)
	if j.ResponseHeaderData != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(j.ResponseHeaderData)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"responseBodyData":`)
	if j.ResponseBodyData != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(j.ResponseBodyData)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"errors":`)
	if j.Errors != nil {
		buf.WriteString(`[`)
		for i, v := range j.Errors {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.HasErrors {
		buf.WriteString(`,"hasErrors":true`)
	} else {
		buf.WriteString(`,"hasErrors":false`)
	}
	if j.Extend != nil {
		buf.WriteString(`,"extend":`)

		{

			err = j.Extend.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"extend":null`)
	}
	if j.Attrs == nil {
		buf.WriteString(`,"attrs":null`)
	} else {
		buf.WriteString(`,"attrs":{ `)
		for key, value := range j.Attrs {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.WriteJsonString(buf, string(value))
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	if j.StorageOnly {
		buf.WriteString(`,"storageOnly":true`)
	} else {
		buf.WriteString(`,"storageOnly":false`)
	}
	buf.WriteString(`,"storagePolicyIds":`)
	if j.StoragePolicyIds != nil {
		buf.WriteString(`[`)
		for i, v := range j.StoragePolicyIds {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogbase = iota
	ffjtAccessLognosuchkey

	ffjtAccessLogId

	ffjtAccessLogServerId

	ffjtAccessLogBackendId

	ffjtAccessLogLocationId

	ffjtAccessLogFastcgiId

	ffjtAccessLogRewriteId

	ffjtAccessLogTeaVersion

	ffjtAccessLogRemoteAddr

	ffjtAccessLogRemotePort

	ffjtAccessLogRemoteUser

	ffjtAccessLogRequestURI

	ffjtAccessLogRequestPath

	ffjtAccessLogAPIPath

	ffjtAccessLogAPIStatus

	ffjtAccessLogRequestLength

	ffjtAccessLogRequestTime

	ffjtAccessLogRequestMethod

	ffjtAccessLogRequestFilename

	ffjtAccessLogScheme

	ffjtAccessLogProto

	ffjtAccessLogBytesSent

	ffjtAccessLogBodyBytesSent

	ffjtAccessLogStatus

	ffjtAccessLogStatusMessage

	ffjtAccessLogSentHeader

	ffjtAccessLogTimeISO8601

	ffjtAccessLogTimeLocal

	ffjtAccessLogMsec

	ffjtAccessLogTimestamp

	ffjtAccessLogHost

	ffjtAccessLogReferer

	ffjtAccessLogUserAgent

	ffjtAccessLogRequest

	ffjtAccessLogContentType

	ffjtAccessLogCookie

	ffjtAccessLogArg

	ffjtAccessLogArgs

	ffjtAccessLogQueryString

	ffjtAccessLogHeader

	ffjtAccessLogServerName

	ffjtAccessLogServerPort

	ffjtAccessLogServerProtocol

	ffjtAccessLogBackendAddress

	ffjtAccessLogFastcgiAddress

	ffjtAccessLogRequestData

	ffjtAccessLogResponseHeaderData

	ffjtAccessLogResponseBodyData

	ffjtAccessLogErrors

	ffjtAccessLogHasErrors

	ffjtAccessLogExtend

	ffjtAccessLogAttrs

	ffjtAccessLogStorageOnly

	ffjtAccessLogStoragePolicyIds
)

var ffjKeyAccessLogId = []byte("id")

var ffjKeyAccessLogServerId = []byte("serverId")

var ffjKeyAccessLogBackendId = []byte("backendId")

var ffjKeyAccessLogLocationId = []byte("locationId")

var ffjKeyAccessLogFastcgiId = []byte("fastcgiId")

var ffjKeyAccessLogRewriteId = []byte("rewriteId")

var ffjKeyAccessLogTeaVersion = []byte("teaVersion")

var ffjKeyAccessLogRemoteAddr = []byte("remoteAddr")

var ffjKeyAccessLogRemotePort = []byte("remotePort")

var ffjKeyAccessLogRemoteUser = []byte("remoteUser")

var ffjKeyAccessLogRequestURI = []byte("requestURI")

var ffjKeyAccessLogRequestPath = []byte("requestPath")

var ffjKeyAccessLogAPIPath = []byte("apiPath")

var ffjKeyAccessLogAPIStatus = []byte("apiStatus")

var ffjKeyAccessLogRequestLength = []byte("requestLength")

var ffjKeyAccessLogRequestTime = []byte("requestTime")

var ffjKeyAccessLogRequestMethod = []byte("requestMethod")

var ffjKeyAccessLogRequestFilename = []byte("requestFilename")

var ffjKeyAccessLogScheme = []byte("scheme")

var ffjKeyAccessLogProto = []byte("proto")

var ffjKeyAccessLogBytesSent = []byte("bytesSent")

var ffjKeyAccessLogBodyBytesSent = []byte("bodyBytesSent")

var ffjKeyAccessLogStatus = []byte("status")

var ffjKeyAccessLogStatusMessage = []byte("statusMessage")

var ffjKeyAccessLogSentHeader = []byte("sentHeader")

var ffjKeyAccessLogTimeISO8601 = []byte("timeISO8601")

var ffjKeyAccessLogTimeLocal = []byte("timeLocal")

var ffjKeyAccessLogMsec = []byte("msec")

var ffjKeyAccessLogTimestamp = []byte("timestamp")

var ffjKeyAccessLogHost = []byte("host")

var ffjKeyAccessLogReferer = []byte("referer")

var ffjKeyAccessLogUserAgent = []byte("userAgent")

var ffjKeyAccessLogRequest = []byte("request")

var ffjKeyAccessLogContentType = []byte("contentType")

var ffjKeyAccessLogCookie = []byte("cookie")

var ffjKeyAccessLogArg = []byte("arg")

var ffjKeyAccessLogArgs = []byte("args")

var ffjKeyAccessLogQueryString = []byte("queryString")

var ffjKeyAccessLogHeader = []byte("header")

var ffjKeyAccessLogServerName = []byte("serverName")

var ffjKeyAccessLogServerPort = []byte("serverPort")

var ffjKeyAccessLogServerProtocol = []byte("serverProtocol")

var ffjKeyAccessLogBackendAddress = []byte("backendAddress")

var ffjKeyAccessLogFastcgiAddress = []byte("fastcgiAddress")

var ffjKeyAccessLogRequestData = []byte("requestData")

var ffjKeyAccessLogResponseHeaderData = []byte("responseHeaderData")

var ffjKeyAccessLogResponseBodyData = []byte("responseBodyData")

var ffjKeyAccessLogErrors = []byte("errors")

var ffjKeyAccessLogHasErrors = []byte("hasErrors")

var ffjKeyAccessLogExtend = []byte("extend")

var ffjKeyAccessLogAttrs = []byte("attrs")

var ffjKeyAccessLogStorageOnly = []byte("storageOnly")

var ffjKeyAccessLogStoragePolicyIds = []byte("storagePolicyIds")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLog) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLog) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLognosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyAccessLogAPIPath, kn) {
						currentKey = ffjtAccessLogAPIPath
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogAPIStatus, kn) {
						currentKey = ffjtAccessLogAPIStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogArg, kn) {
						currentKey = ffjtAccessLogArg
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogArgs, kn) {
						currentKey = ffjtAccessLogArgs
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogAttrs, kn) {
						currentKey = ffjtAccessLogAttrs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyAccessLogBackendId, kn) {
						currentKey = ffjtAccessLogBackendId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogBytesSent, kn) {
						currentKey = ffjtAccessLogBytesSent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogBodyBytesSent, kn) {
						currentKey = ffjtAccessLogBodyBytesSent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogBackendAddress, kn) {
						currentKey = ffjtAccessLogBackendAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyAccessLogContentType, kn) {
						currentKey = ffjtAccessLogContentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogCookie, kn) {
						currentKey = ffjtAccessLogCookie
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyAccessLogErrors, kn) {
						currentKey = ffjtAccessLogErrors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogExtend, kn) {
						currentKey = ffjtAccessLogExtend
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAccessLogFastcgiId, kn) {
						currentKey = ffjtAccessLogFastcgiId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogFastcgiAddress, kn) {
						currentKey = ffjtAccessLogFastcgiAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyAccessLogHost, kn) {
						currentKey = ffjtAccessLogHost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogHeader, kn) {
						currentKey = ffjtAccessLogHeader
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogHasErrors, kn) {
						currentKey = ffjtAccessLogHasErrors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyAccessLogId, kn) {
						currentKey = ffjtAccessLogId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyAccessLogLocationId, kn) {
						currentKey = ffjtAccessLogLocationId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogMsec, kn) {
						currentKey = ffjtAccessLogMsec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAccessLogProto, kn) {
						currentKey = ffjtAccessLogProto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyAccessLogQueryString, kn) {
						currentKey = ffjtAccessLogQueryString
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyAccessLogRewriteId, kn) {
						currentKey = ffjtAccessLogRewriteId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRemoteAddr, kn) {
						currentKey = ffjtAccessLogRemoteAddr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRemotePort, kn) {
						currentKey = ffjtAccessLogRemotePort
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRemoteUser, kn) {
						currentKey = ffjtAccessLogRemoteUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestURI, kn) {
						currentKey = ffjtAccessLogRequestURI
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestPath, kn) {
						currentKey = ffjtAccessLogRequestPath
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestLength, kn) {
						currentKey = ffjtAccessLogRequestLength
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestTime, kn) {
						currentKey = ffjtAccessLogRequestTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestMethod, kn) {
						currentKey = ffjtAccessLogRequestMethod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestFilename, kn) {
						currentKey = ffjtAccessLogRequestFilename
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogReferer, kn) {
						currentKey = ffjtAccessLogReferer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequest, kn) {
						currentKey = ffjtAccessLogRequest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogRequestData, kn) {
						currentKey = ffjtAccessLogRequestData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogResponseHeaderData, kn) {
						currentKey = ffjtAccessLogResponseHeaderData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogResponseBodyData, kn) {
						currentKey = ffjtAccessLogResponseBodyData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAccessLogServerId, kn) {
						currentKey = ffjtAccessLogServerId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogScheme, kn) {
						currentKey = ffjtAccessLogScheme
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogStatus, kn) {
						currentKey = ffjtAccessLogStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogStatusMessage, kn) {
						currentKey = ffjtAccessLogStatusMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogSentHeader, kn) {
						currentKey = ffjtAccessLogSentHeader
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogServerName, kn) {
						currentKey = ffjtAccessLogServerName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogServerPort, kn) {
						currentKey = ffjtAccessLogServerPort
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogServerProtocol, kn) {
						currentKey = ffjtAccessLogServerProtocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogStorageOnly, kn) {
						currentKey = ffjtAccessLogStorageOnly
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogStoragePolicyIds, kn) {
						currentKey = ffjtAccessLogStoragePolicyIds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAccessLogTeaVersion, kn) {
						currentKey = ffjtAccessLogTeaVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogTimeISO8601, kn) {
						currentKey = ffjtAccessLogTimeISO8601
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogTimeLocal, kn) {
						currentKey = ffjtAccessLogTimeLocal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogTimestamp, kn) {
						currentKey = ffjtAccessLogTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyAccessLogUserAgent, kn) {
						currentKey = ffjtAccessLogUserAgent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAccessLogStoragePolicyIds, kn) {
					currentKey = ffjtAccessLogStoragePolicyIds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogStorageOnly, kn) {
					currentKey = ffjtAccessLogStorageOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogAttrs, kn) {
					currentKey = ffjtAccessLogAttrs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogExtend, kn) {
					currentKey = ffjtAccessLogExtend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogHasErrors, kn) {
					currentKey = ffjtAccessLogHasErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogErrors, kn) {
					currentKey = ffjtAccessLogErrors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogResponseBodyData, kn) {
					currentKey = ffjtAccessLogResponseBodyData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogResponseHeaderData, kn) {
					currentKey = ffjtAccessLogResponseHeaderData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestData, kn) {
					currentKey = ffjtAccessLogRequestData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogFastcgiAddress, kn) {
					currentKey = ffjtAccessLogFastcgiAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogBackendAddress, kn) {
					currentKey = ffjtAccessLogBackendAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogServerProtocol, kn) {
					currentKey = ffjtAccessLogServerProtocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogServerPort, kn) {
					currentKey = ffjtAccessLogServerPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogServerName, kn) {
					currentKey = ffjtAccessLogServerName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogHeader, kn) {
					currentKey = ffjtAccessLogHeader
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogQueryString, kn) {
					currentKey = ffjtAccessLogQueryString
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogArgs, kn) {
					currentKey = ffjtAccessLogArgs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogArg, kn) {
					currentKey = ffjtAccessLogArg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogCookie, kn) {
					currentKey = ffjtAccessLogCookie
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogContentType, kn) {
					currentKey = ffjtAccessLogContentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequest, kn) {
					currentKey = ffjtAccessLogRequest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogUserAgent, kn) {
					currentKey = ffjtAccessLogUserAgent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogReferer, kn) {
					currentKey = ffjtAccessLogReferer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogHost, kn) {
					currentKey = ffjtAccessLogHost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogTimestamp, kn) {
					currentKey = ffjtAccessLogTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogMsec, kn) {
					currentKey = ffjtAccessLogMsec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogTimeLocal, kn) {
					currentKey = ffjtAccessLogTimeLocal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogTimeISO8601, kn) {
					currentKey = ffjtAccessLogTimeISO8601
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogSentHeader, kn) {
					currentKey = ffjtAccessLogSentHeader
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogStatusMessage, kn) {
					currentKey = ffjtAccessLogStatusMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogStatus, kn) {
					currentKey = ffjtAccessLogStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogBodyBytesSent, kn) {
					currentKey = ffjtAccessLogBodyBytesSent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogBytesSent, kn) {
					currentKey = ffjtAccessLogBytesSent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogProto, kn) {
					currentKey = ffjtAccessLogProto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogScheme, kn) {
					currentKey = ffjtAccessLogScheme
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestFilename, kn) {
					currentKey = ffjtAccessLogRequestFilename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestMethod, kn) {
					currentKey = ffjtAccessLogRequestMethod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestTime, kn) {
					currentKey = ffjtAccessLogRequestTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestLength, kn) {
					currentKey = ffjtAccessLogRequestLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogAPIStatus, kn) {
					currentKey = ffjtAccessLogAPIStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogAPIPath, kn) {
					currentKey = ffjtAccessLogAPIPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestPath, kn) {
					currentKey = ffjtAccessLogRequestPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRequestURI, kn) {
					currentKey = ffjtAccessLogRequestURI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogRemoteUser, kn) {
					currentKey = ffjtAccessLogRemoteUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogRemotePort, kn) {
					currentKey = ffjtAccessLogRemotePort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogRemoteAddr, kn) {
					currentKey = ffjtAccessLogRemoteAddr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogTeaVersion, kn) {
					currentKey = ffjtAccessLogTeaVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogRewriteId, kn) {
					currentKey = ffjtAccessLogRewriteId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogFastcgiId, kn) {
					currentKey = ffjtAccessLogFastcgiId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogLocationId, kn) {
					currentKey = ffjtAccessLogLocationId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogBackendId, kn) {
					currentKey = ffjtAccessLogBackendId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogServerId, kn) {
					currentKey = ffjtAccessLogServerId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogId, kn) {
					currentKey = ffjtAccessLogId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLognosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogId:
					goto handle_Id

				case ffjtAccessLogServerId:
					goto handle_ServerId

				case ffjtAccessLogBackendId:
					goto handle_BackendId

				case ffjtAccessLogLocationId:
					goto handle_LocationId

				case ffjtAccessLogFastcgiId:
					goto handle_FastcgiId

				case ffjtAccessLogRewriteId:
					goto handle_RewriteId

				case ffjtAccessLogTeaVersion:
					goto handle_TeaVersion

				case ffjtAccessLogRemoteAddr:
					goto handle_RemoteAddr

				case ffjtAccessLogRemotePort:
					goto handle_RemotePort

				case ffjtAccessLogRemoteUser:
					goto handle_RemoteUser

				case ffjtAccessLogRequestURI:
					goto handle_RequestURI

				case ffjtAccessLogRequestPath:
					goto handle_RequestPath

				case ffjtAccessLogAPIPath:
					goto handle_APIPath

				case ffjtAccessLogAPIStatus:
					goto handle_APIStatus

				case ffjtAccessLogRequestLength:
					goto handle_RequestLength

				case ffjtAccessLogRequestTime:
					goto handle_RequestTime

				case ffjtAccessLogRequestMethod:
					goto handle_RequestMethod

				case ffjtAccessLogRequestFilename:
					goto handle_RequestFilename

				case ffjtAccessLogScheme:
					goto handle_Scheme

				case ffjtAccessLogProto:
					goto handle_Proto

				case ffjtAccessLogBytesSent:
					goto handle_BytesSent

				case ffjtAccessLogBodyBytesSent:
					goto handle_BodyBytesSent

				case ffjtAccessLogStatus:
					goto handle_Status

				case ffjtAccessLogStatusMessage:
					goto handle_StatusMessage

				case ffjtAccessLogSentHeader:
					goto handle_SentHeader

				case ffjtAccessLogTimeISO8601:
					goto handle_TimeISO8601

				case ffjtAccessLogTimeLocal:
					goto handle_TimeLocal

				case ffjtAccessLogMsec:
					goto handle_Msec

				case ffjtAccessLogTimestamp:
					goto handle_Timestamp

				case ffjtAccessLogHost:
					goto handle_Host

				case ffjtAccessLogReferer:
					goto handle_Referer

				case ffjtAccessLogUserAgent:
					goto handle_UserAgent

				case ffjtAccessLogRequest:
					goto handle_Request

				case ffjtAccessLogContentType:
					goto handle_ContentType

				case ffjtAccessLogCookie:
					goto handle_Cookie

				case ffjtAccessLogArg:
					goto handle_Arg

				case ffjtAccessLogArgs:
					goto handle_Args

				case ffjtAccessLogQueryString:
					goto handle_QueryString

				case ffjtAccessLogHeader:
					goto handle_Header

				case ffjtAccessLogServerName:
					goto handle_ServerName

				case ffjtAccessLogServerPort:
					goto handle_ServerPort

				case ffjtAccessLogServerProtocol:
					goto handle_ServerProtocol

				case ffjtAccessLogBackendAddress:
					goto handle_BackendAddress

				case ffjtAccessLogFastcgiAddress:
					goto handle_FastcgiAddress

				case ffjtAccessLogRequestData:
					goto handle_RequestData

				case ffjtAccessLogResponseHeaderData:
					goto handle_ResponseHeaderData

				case ffjtAccessLogResponseBodyData:
					goto handle_ResponseBodyData

				case ffjtAccessLogErrors:
					goto handle_Errors

				case ffjtAccessLogHasErrors:
					goto handle_HasErrors

				case ffjtAccessLogExtend:
					goto handle_Extend

				case ffjtAccessLogAttrs:
					goto handle_Attrs

				case ffjtAccessLogStorageOnly:
					goto handle_StorageOnly

				case ffjtAccessLogStoragePolicyIds:
					goto handle_StoragePolicyIds

				case ffjtAccessLognosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Id:

	/* handler: j.Id type=primitive.ObjectID kind=array quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Id.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ServerId:

	/* handler: j.ServerId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ServerId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BackendId:

	/* handler: j.BackendId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BackendId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LocationId:

	/* handler: j.LocationId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LocationId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FastcgiId:

	/* handler: j.FastcgiId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FastcgiId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RewriteId:

	/* handler: j.RewriteId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RewriteId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TeaVersion:

	/* handler: j.TeaVersion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TeaVersion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoteAddr:

	/* handler: j.RemoteAddr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RemoteAddr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemotePort:

	/* handler: j.RemotePort type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RemotePort = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoteUser:

	/* handler: j.RemoteUser type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RemoteUser = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestURI:

	/* handler: j.RequestURI type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RequestURI = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestPath:

	/* handler: j.RequestPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RequestPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIPath:

	/* handler: j.APIPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.APIPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIStatus:

	/* handler: j.APIStatus type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.APIStatus = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestLength:

	/* handler: j.RequestLength type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RequestLength = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestTime:

	/* handler: j.RequestTime type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RequestTime = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestMethod:

	/* handler: j.RequestMethod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RequestMethod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestFilename:

	/* handler: j.RequestFilename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RequestFilename = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scheme:

	/* handler: j.Scheme type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Scheme = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Proto:

	/* handler: j.Proto type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Proto = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BytesSent:

	/* handler: j.BytesSent type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BytesSent = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BodyBytesSent:

	/* handler: j.BodyBytesSent type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.BodyBytesSent = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StatusMessage:

	/* handler: j.StatusMessage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StatusMessage = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SentHeader:

	/* handler: j.SentHeader type=map[string][]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SentHeader = nil
		} else {

			j.SentHeader = make(map[string][]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJSentHeader []string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJSentHeader type=[]string kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJSentHeader = nil
					} else {

						tmpJSentHeader = []string{}

						wantVal := true

						for {

							var tmpTmpJSentHeader string

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_brace {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: tmpTmpJSentHeader type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									tmpTmpJSentHeader = string(string(outBuf))

								}
							}

							tmpJSentHeader = append(tmpJSentHeader, tmpTmpJSentHeader)

							wantVal = false
						}
					}
				}

				j.SentHeader[k] = tmpJSentHeader

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeISO8601:

	/* handler: j.TimeISO8601 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TimeISO8601 = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeLocal:

	/* handler: j.TimeLocal type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TimeLocal = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Msec:

	/* handler: j.Msec type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Msec = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Timestamp = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Host:

	/* handler: j.Host type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Host = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Referer:

	/* handler: j.Referer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Referer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserAgent:

	/* handler: j.UserAgent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserAgent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Request:

	/* handler: j.Request type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Request = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContentType:

	/* handler: j.ContentType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ContentType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cookie:

	/* handler: j.Cookie type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Cookie = nil
		} else {

			j.Cookie = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJCookie string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJCookie type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCookie = string(string(outBuf))

					}
				}

				j.Cookie[k] = tmpJCookie

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Arg:

	/* handler: j.Arg type=map[string][]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Arg = nil
		} else {

			j.Arg = make(map[string][]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJArg []string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJArg type=[]string kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJArg = nil
					} else {

						tmpJArg = []string{}

						wantVal := true

						for {

							var tmpTmpJArg string

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_brace {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: tmpTmpJArg type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									tmpTmpJArg = string(string(outBuf))

								}
							}

							tmpJArg = append(tmpJArg, tmpTmpJArg)

							wantVal = false
						}
					}
				}

				j.Arg[k] = tmpJArg

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Args:

	/* handler: j.Args type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Args = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QueryString:

	/* handler: j.QueryString type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.QueryString = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Header:

	/* handler: j.Header type=map[string][]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Header = nil
		} else {

			j.Header = make(map[string][]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJHeader []string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJHeader type=[]string kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJHeader = nil
					} else {

						tmpJHeader = []string{}

						wantVal := true

						for {

							var tmpTmpJHeader string

							tok = fs.Scan()
							if tok == fflib.FFTok_error {
								goto tokerror
							}
							if tok == fflib.FFTok_right_brace {
								break
							}

							if tok == fflib.FFTok_comma {
								if wantVal == true {
									// TODO(pquerna): this isn't an ideal error message, this handles
									// things like [,,,] as an array value.
									return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
								}
								continue
							} else {
								wantVal = true
							}

							/* handler: tmpTmpJHeader type=string kind=string quoted=false*/

							{

								{
									if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
										return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
									}
								}

								if tok == fflib.FFTok_null {

								} else {

									outBuf := fs.Output.Bytes()

									tmpTmpJHeader = string(string(outBuf))

								}
							}

							tmpJHeader = append(tmpJHeader, tmpTmpJHeader)

							wantVal = false
						}
					}
				}

				j.Header[k] = tmpJHeader

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ServerName:

	/* handler: j.ServerName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ServerName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ServerPort:

	/* handler: j.ServerPort type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ServerPort = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ServerProtocol:

	/* handler: j.ServerProtocol type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ServerProtocol = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BackendAddress:

	/* handler: j.BackendAddress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BackendAddress = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FastcgiAddress:

	/* handler: j.FastcgiAddress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FastcgiAddress = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestData:

	/* handler: j.RequestData type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.RequestData = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&j.RequestData).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResponseHeaderData:

	/* handler: j.ResponseHeaderData type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ResponseHeaderData = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&j.ResponseHeaderData).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResponseBodyData:

	/* handler: j.ResponseBodyData type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ResponseBodyData = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&j.ResponseBodyData).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Errors:

	/* handler: j.Errors type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Errors = nil
		} else {

			j.Errors = []string{}

			wantVal := true

			for {

				var tmpJErrors string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJErrors type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJErrors = string(string(outBuf))

					}
				}

				j.Errors = append(j.Errors, tmpJErrors)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HasErrors:

	/* handler: j.HasErrors type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HasErrors = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HasErrors = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extend:

	/* handler: j.Extend type=tealogs.AccessLogExtend kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Extend = nil

		} else {

			if j.Extend == nil {
				j.Extend = new(AccessLogExtend)
			}

			err = j.Extend.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attrs:

	/* handler: j.Attrs type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Attrs = nil
		} else {

			j.Attrs = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJAttrs string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJAttrs type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJAttrs = string(string(outBuf))

					}
				}

				j.Attrs[k] = tmpJAttrs

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StorageOnly:

	/* handler: j.StorageOnly type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.StorageOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.StorageOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StoragePolicyIds:

	/* handler: j.StoragePolicyIds type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.StoragePolicyIds = nil
		} else {

			j.StoragePolicyIds = []string{}

			wantVal := true

			for {

				var tmpJStoragePolicyIds string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJStoragePolicyIds type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJStoragePolicyIds = string(string(outBuf))

					}
				}

				j.StoragePolicyIds = append(j.StoragePolicyIds, tmpJStoragePolicyIds)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogClient) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogClient) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"os":`)

	{

		err = j.OS.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"device":`)

	{

		err = j.Device.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"browser":`)

	{

		err = j.Browser.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogClientbase = iota
	ffjtAccessLogClientnosuchkey

	ffjtAccessLogClientOS

	ffjtAccessLogClientDevice

	ffjtAccessLogClientBrowser
)

var ffjKeyAccessLogClientOS = []byte("os")

var ffjKeyAccessLogClientDevice = []byte("device")

var ffjKeyAccessLogClientBrowser = []byte("browser")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogClient) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogClient) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogClientbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogClientnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyAccessLogClientBrowser, kn) {
						currentKey = ffjtAccessLogClientBrowser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyAccessLogClientDevice, kn) {
						currentKey = ffjtAccessLogClientDevice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyAccessLogClientOS, kn) {
						currentKey = ffjtAccessLogClientOS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAccessLogClientBrowser, kn) {
					currentKey = ffjtAccessLogClientBrowser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientDevice, kn) {
					currentKey = ffjtAccessLogClientDevice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogClientOS, kn) {
					currentKey = ffjtAccessLogClientOS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogClientnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogClientOS:
					goto handle_OS

				case ffjtAccessLogClientDevice:
					goto handle_Device

				case ffjtAccessLogClientBrowser:
					goto handle_Browser

				case ffjtAccessLogClientnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_OS:

	/* handler: j.OS type=tealogs.AccessLogClientOS kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.OS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Device:

	/* handler: j.Device type=tealogs.AccessLogClientDevice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Device.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Browser:

	/* handler: j.Browser type=tealogs.AccessLogClientBrowser kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Browser.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogClientBrowser) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogClientBrowser) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"family":`)
	fflib.WriteJsonString(buf, string(j.Family))
	buf.WriteString(`,"major":`)
	fflib.WriteJsonString(buf, string(j.Major))
	buf.WriteString(`,"minor":`)
	fflib.WriteJsonString(buf, string(j.Minor))
	buf.WriteString(`,"patch":`)
	fflib.WriteJsonString(buf, string(j.Patch))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogClientBrowserbase = iota
	ffjtAccessLogClientBrowsernosuchkey

	ffjtAccessLogClientBrowserFamily

	ffjtAccessLogClientBrowserMajor

	ffjtAccessLogClientBrowserMinor

	ffjtAccessLogClientBrowserPatch
)

var ffjKeyAccessLogClientBrowserFamily = []byte("family")

var ffjKeyAccessLogClientBrowserMajor = []byte("major")

var ffjKeyAccessLogClientBrowserMinor = []byte("minor")

var ffjKeyAccessLogClientBrowserPatch = []byte("patch")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogClientBrowser) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogClientBrowser) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogClientBrowserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogClientBrowsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyAccessLogClientBrowserFamily, kn) {
						currentKey = ffjtAccessLogClientBrowserFamily
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogClientBrowserMajor, kn) {
						currentKey = ffjtAccessLogClientBrowserMajor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogClientBrowserMinor, kn) {
						currentKey = ffjtAccessLogClientBrowserMinor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAccessLogClientBrowserPatch, kn) {
						currentKey = ffjtAccessLogClientBrowserPatch
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientBrowserPatch, kn) {
					currentKey = ffjtAccessLogClientBrowserPatch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientBrowserMinor, kn) {
					currentKey = ffjtAccessLogClientBrowserMinor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientBrowserMajor, kn) {
					currentKey = ffjtAccessLogClientBrowserMajor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientBrowserFamily, kn) {
					currentKey = ffjtAccessLogClientBrowserFamily
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogClientBrowsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogClientBrowserFamily:
					goto handle_Family

				case ffjtAccessLogClientBrowserMajor:
					goto handle_Major

				case ffjtAccessLogClientBrowserMinor:
					goto handle_Minor

				case ffjtAccessLogClientBrowserPatch:
					goto handle_Patch

				case ffjtAccessLogClientBrowsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Family:

	/* handler: j.Family type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Family = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Major:

	/* handler: j.Major type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Major = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Minor:

	/* handler: j.Minor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Minor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Patch:

	/* handler: j.Patch type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Patch = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogClientDevice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogClientDevice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"family":`)
	fflib.WriteJsonString(buf, string(j.Family))
	buf.WriteString(`,"brand":`)
	fflib.WriteJsonString(buf, string(j.Brand))
	buf.WriteString(`,"model":`)
	fflib.WriteJsonString(buf, string(j.Model))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogClientDevicebase = iota
	ffjtAccessLogClientDevicenosuchkey

	ffjtAccessLogClientDeviceFamily

	ffjtAccessLogClientDeviceBrand

	ffjtAccessLogClientDeviceModel
)

var ffjKeyAccessLogClientDeviceFamily = []byte("family")

var ffjKeyAccessLogClientDeviceBrand = []byte("brand")

var ffjKeyAccessLogClientDeviceModel = []byte("model")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogClientDevice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogClientDevice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogClientDevicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogClientDevicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyAccessLogClientDeviceBrand, kn) {
						currentKey = ffjtAccessLogClientDeviceBrand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAccessLogClientDeviceFamily, kn) {
						currentKey = ffjtAccessLogClientDeviceFamily
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogClientDeviceModel, kn) {
						currentKey = ffjtAccessLogClientDeviceModel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientDeviceModel, kn) {
					currentKey = ffjtAccessLogClientDeviceModel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientDeviceBrand, kn) {
					currentKey = ffjtAccessLogClientDeviceBrand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientDeviceFamily, kn) {
					currentKey = ffjtAccessLogClientDeviceFamily
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogClientDevicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogClientDeviceFamily:
					goto handle_Family

				case ffjtAccessLogClientDeviceBrand:
					goto handle_Brand

				case ffjtAccessLogClientDeviceModel:
					goto handle_Model

				case ffjtAccessLogClientDevicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Family:

	/* handler: j.Family type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Family = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Brand:

	/* handler: j.Brand type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Brand = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Model:

	/* handler: j.Model type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Model = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogClientOS) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogClientOS) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"family":`)
	fflib.WriteJsonString(buf, string(j.Family))
	buf.WriteString(`,"major":`)
	fflib.WriteJsonString(buf, string(j.Major))
	buf.WriteString(`,"minor":`)
	fflib.WriteJsonString(buf, string(j.Minor))
	buf.WriteString(`,"patch":`)
	fflib.WriteJsonString(buf, string(j.Patch))
	buf.WriteString(`,"patchMinor":`)
	fflib.WriteJsonString(buf, string(j.PatchMinor))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogClientOSbase = iota
	ffjtAccessLogClientOSnosuchkey

	ffjtAccessLogClientOSFamily

	ffjtAccessLogClientOSMajor

	ffjtAccessLogClientOSMinor

	ffjtAccessLogClientOSPatch

	ffjtAccessLogClientOSPatchMinor
)

var ffjKeyAccessLogClientOSFamily = []byte("family")

var ffjKeyAccessLogClientOSMajor = []byte("major")

var ffjKeyAccessLogClientOSMinor = []byte("minor")

var ffjKeyAccessLogClientOSPatch = []byte("patch")

var ffjKeyAccessLogClientOSPatchMinor = []byte("patchMinor")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogClientOS) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogClientOS) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogClientOSbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogClientOSnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyAccessLogClientOSFamily, kn) {
						currentKey = ffjtAccessLogClientOSFamily
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogClientOSMajor, kn) {
						currentKey = ffjtAccessLogClientOSMajor
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogClientOSMinor, kn) {
						currentKey = ffjtAccessLogClientOSMinor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAccessLogClientOSPatch, kn) {
						currentKey = ffjtAccessLogClientOSPatch
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogClientOSPatchMinor, kn) {
						currentKey = ffjtAccessLogClientOSPatchMinor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientOSPatchMinor, kn) {
					currentKey = ffjtAccessLogClientOSPatchMinor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientOSPatch, kn) {
					currentKey = ffjtAccessLogClientOSPatch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientOSMinor, kn) {
					currentKey = ffjtAccessLogClientOSMinor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientOSMajor, kn) {
					currentKey = ffjtAccessLogClientOSMajor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogClientOSFamily, kn) {
					currentKey = ffjtAccessLogClientOSFamily
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogClientOSnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogClientOSFamily:
					goto handle_Family

				case ffjtAccessLogClientOSMajor:
					goto handle_Major

				case ffjtAccessLogClientOSMinor:
					goto handle_Minor

				case ffjtAccessLogClientOSPatch:
					goto handle_Patch

				case ffjtAccessLogClientOSPatchMinor:
					goto handle_PatchMinor

				case ffjtAccessLogClientOSnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Family:

	/* handler: j.Family type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Family = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Major:

	/* handler: j.Major type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Major = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Minor:

	/* handler: j.Minor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Minor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Patch:

	/* handler: j.Patch type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Patch = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PatchMinor:

	/* handler: j.PatchMinor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PatchMinor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogExtend) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogExtend) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file":`)

	{

		err = j.File.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"client":`)

	{

		err = j.Client.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"geo":`)

	{

		err = j.Geo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogExtendbase = iota
	ffjtAccessLogExtendnosuchkey

	ffjtAccessLogExtendFile

	ffjtAccessLogExtendClient

	ffjtAccessLogExtendGeo
)

var ffjKeyAccessLogExtendFile = []byte("file")

var ffjKeyAccessLogExtendClient = []byte("client")

var ffjKeyAccessLogExtendGeo = []byte("geo")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogExtend) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogExtend) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogExtendbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogExtendnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyAccessLogExtendClient, kn) {
						currentKey = ffjtAccessLogExtendClient
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAccessLogExtendFile, kn) {
						currentKey = ffjtAccessLogExtendFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyAccessLogExtendGeo, kn) {
						currentKey = ffjtAccessLogExtendGeo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogExtendGeo, kn) {
					currentKey = ffjtAccessLogExtendGeo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogExtendClient, kn) {
					currentKey = ffjtAccessLogExtendClient
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogExtendFile, kn) {
					currentKey = ffjtAccessLogExtendFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogExtendnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogExtendFile:
					goto handle_File

				case ffjtAccessLogExtendClient:
					goto handle_Client

				case ffjtAccessLogExtendGeo:
					goto handle_Geo

				case ffjtAccessLogExtendnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_File:

	/* handler: j.File type=tealogs.AccessLogFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.File.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Client:

	/* handler: j.Client type=tealogs.AccessLogClient kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Client.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Geo:

	/* handler: j.Geo type=tealogs.AccessLogGeo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Geo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"mimeType":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteString(`,"extension":`)
	fflib.WriteJsonString(buf, string(j.Extension))
	buf.WriteString(`,"charset":`)
	fflib.WriteJsonString(buf, string(j.Charset))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogFilebase = iota
	ffjtAccessLogFilenosuchkey

	ffjtAccessLogFileMimeType

	ffjtAccessLogFileExtension

	ffjtAccessLogFileCharset
)

var ffjKeyAccessLogFileMimeType = []byte("mimeType")

var ffjKeyAccessLogFileExtension = []byte("extension")

var ffjKeyAccessLogFileCharset = []byte("charset")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyAccessLogFileCharset, kn) {
						currentKey = ffjtAccessLogFileCharset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyAccessLogFileExtension, kn) {
						currentKey = ffjtAccessLogFileExtension
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogFileMimeType, kn) {
						currentKey = ffjtAccessLogFileMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAccessLogFileCharset, kn) {
					currentKey = ffjtAccessLogFileCharset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogFileExtension, kn) {
					currentKey = ffjtAccessLogFileExtension
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogFileMimeType, kn) {
					currentKey = ffjtAccessLogFileMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogFileMimeType:
					goto handle_MimeType

				case ffjtAccessLogFileExtension:
					goto handle_Extension

				case ffjtAccessLogFileCharset:
					goto handle_Charset

				case ffjtAccessLogFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extension:

	/* handler: j.Extension type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Extension = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Charset:

	/* handler: j.Charset type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Charset = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogGeo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogGeo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"region":`)
	fflib.WriteJsonString(buf, string(j.Region))
	buf.WriteString(`,"state":`)
	fflib.WriteJsonString(buf, string(j.State))
	buf.WriteString(`,"city":`)
	fflib.WriteJsonString(buf, string(j.City))
	buf.WriteString(`,"location":`)

	{

		err = j.Location.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogGeobase = iota
	ffjtAccessLogGeonosuchkey

	ffjtAccessLogGeoRegion

	ffjtAccessLogGeoState

	ffjtAccessLogGeoCity

	ffjtAccessLogGeoLocation
)

var ffjKeyAccessLogGeoRegion = []byte("region")

var ffjKeyAccessLogGeoState = []byte("state")

var ffjKeyAccessLogGeoCity = []byte("city")

var ffjKeyAccessLogGeoLocation = []byte("location")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogGeo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogGeo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogGeobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogGeonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyAccessLogGeoCity, kn) {
						currentKey = ffjtAccessLogGeoCity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyAccessLogGeoLocation, kn) {
						currentKey = ffjtAccessLogGeoLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyAccessLogGeoRegion, kn) {
						currentKey = ffjtAccessLogGeoRegion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyAccessLogGeoState, kn) {
						currentKey = ffjtAccessLogGeoState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoLocation, kn) {
					currentKey = ffjtAccessLogGeoLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoCity, kn) {
					currentKey = ffjtAccessLogGeoCity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogGeoState, kn) {
					currentKey = ffjtAccessLogGeoState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoRegion, kn) {
					currentKey = ffjtAccessLogGeoRegion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogGeonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogGeoRegion:
					goto handle_Region

				case ffjtAccessLogGeoState:
					goto handle_State

				case ffjtAccessLogGeoCity:
					goto handle_City

				case ffjtAccessLogGeoLocation:
					goto handle_Location

				case ffjtAccessLogGeonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Region:

	/* handler: j.Region type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Region = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: j.State type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.State = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_City:

	/* handler: j.City type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.City = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=tealogs.AccessLogGeoLocation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *AccessLogGeoLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *AccessLogGeoLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 64)
	buf.WriteString(`,"timeZone":`)
	fflib.WriteJsonString(buf, string(j.TimeZone))
	buf.WriteString(`,"accuracyRadius":`)
	fflib.FormatBits2(buf, uint64(j.AccuracyRadius), 10, false)
	buf.WriteString(`,"metroCode":`)
	fflib.FormatBits2(buf, uint64(j.MetroCode), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAccessLogGeoLocationbase = iota
	ffjtAccessLogGeoLocationnosuchkey

	ffjtAccessLogGeoLocationLatitude

	ffjtAccessLogGeoLocationLongitude

	ffjtAccessLogGeoLocationTimeZone

	ffjtAccessLogGeoLocationAccuracyRadius

	ffjtAccessLogGeoLocationMetroCode
)

var ffjKeyAccessLogGeoLocationLatitude = []byte("latitude")

var ffjKeyAccessLogGeoLocationLongitude = []byte("longitude")

var ffjKeyAccessLogGeoLocationTimeZone = []byte("timeZone")

var ffjKeyAccessLogGeoLocationAccuracyRadius = []byte("accuracyRadius")

var ffjKeyAccessLogGeoLocationMetroCode = []byte("metroCode")

// UnmarshalJSON umarshall json - template of ffjson
func (j *AccessLogGeoLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *AccessLogGeoLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAccessLogGeoLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAccessLogGeoLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyAccessLogGeoLocationAccuracyRadius, kn) {
						currentKey = ffjtAccessLogGeoLocationAccuracyRadius
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyAccessLogGeoLocationLatitude, kn) {
						currentKey = ffjtAccessLogGeoLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAccessLogGeoLocationLongitude, kn) {
						currentKey = ffjtAccessLogGeoLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAccessLogGeoLocationMetroCode, kn) {
						currentKey = ffjtAccessLogGeoLocationMetroCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAccessLogGeoLocationTimeZone, kn) {
						currentKey = ffjtAccessLogGeoLocationTimeZone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoLocationMetroCode, kn) {
					currentKey = ffjtAccessLogGeoLocationMetroCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAccessLogGeoLocationAccuracyRadius, kn) {
					currentKey = ffjtAccessLogGeoLocationAccuracyRadius
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoLocationTimeZone, kn) {
					currentKey = ffjtAccessLogGeoLocationTimeZone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoLocationLongitude, kn) {
					currentKey = ffjtAccessLogGeoLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAccessLogGeoLocationLatitude, kn) {
					currentKey = ffjtAccessLogGeoLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAccessLogGeoLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAccessLogGeoLocationLatitude:
					goto handle_Latitude

				case ffjtAccessLogGeoLocationLongitude:
					goto handle_Longitude

				case ffjtAccessLogGeoLocationTimeZone:
					goto handle_TimeZone

				case ffjtAccessLogGeoLocationAccuracyRadius:
					goto handle_AccuracyRadius

				case ffjtAccessLogGeoLocationMetroCode:
					goto handle_MetroCode

				case ffjtAccessLogGeoLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: j.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeZone:

	/* handler: j.TimeZone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TimeZone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccuracyRadius:

	/* handler: j.AccuracyRadius type=uint16 kind=uint16 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint16", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 16)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.AccuracyRadius = uint16(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MetroCode:

	/* handler: j.MetroCode type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MetroCode = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
